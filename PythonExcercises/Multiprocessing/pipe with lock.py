'''
Created on Jan 15, 2016

@author: test
'''

import multiprocessing
import random

def writer(pipe, lock):
	while True:
		lock.acquire()
		value = random.randrange(10)
		pipe.send(value)
		print '1Value sent: %s' %value
		lock.release()
		
def second_writer(pipe, lock):
	while True:
		lock.acquire()
		value = random.randrange(10)
		pipe.send(value)
		print '2Value sent: %s' %value
		lock.release()
	
		
def reader(pipe, lock):
	while True:		
		value = pipe.recv()
		print 'received: %s' %value		
		
if __name__ == '__main__':

	pipe_in, pipe_out = multiprocessing.Pipe()	# generates pairs of connection objects generated by Pipe, two ends
	
	lock = multiprocessing.Lock()
	
	# watch out! the data in pipe may become corrupted if two processes (or threads) try to read from or write to the same end of the same pipe at the same time
	
	p1 = multiprocessing.Process(target=writer, args=(pipe_in, lock))
	p2 = multiprocessing.Process(target=reader, args=(pipe_out, lock))
	p3 = multiprocessing.Process(target=second_writer, args=(pipe_in, lock))
	
	p1.start()
	p2.start()
	p3.start()